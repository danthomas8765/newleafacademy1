<style>
	.carousel-container {
		width: 100%; 
		margin: 2em 0;
		overflow: hidden;
		box-sizing: border-box;
	}

	.testimonial-track {
		display: flex;
	}

	.testimonial-slide {
		flex: 0 0 60%;
		max-width: 600px;
		padding: 1.5em;
		text-align: center;
		border: 1px solid #ddd;
		border-radius: 8px;
		margin: 0 10px;
		box-sizing: border-box; 
		background-color: #F0F8FF; /* Very very light baby blue */
	}
	
	.testimonial-slide p {
		font-style: italic;
	}

	.testimonial-slide .author {
		font-weight: bold;
		font-style: normal;
		margin-top: 1em;
	}

	.carousel-nav {
		text-align: center;
		margin-top: 1em;
	}

	.carousel-button {
		background-color: var(--accent);
		color: white;
		border: none;
		font-size: 1.5em;
		cursor: pointer;
		border-radius: 50%;
		width: 45px;
		height: 45px;
		margin: 0 10px;
		transition: background-color 0.3s;
	}
	
	.carousel-button:hover {
		background-color: var(--accent-dark);
	}

	/* --- Tablet Responsive Styles --- */
	@media (max-width: 768px) {
		.testimonial-slide {
			flex-basis: 80%;
			margin: 0 10px;
		}
	}

	/* --- Mobile Responsive Styles --- */
	@media (max-width: 480px) {
		.carousel-container {
			padding: 0 20px;
		}
		.testimonial-slide {
			flex-basis: 100%; 
			margin: 0;
		}
	}
    </style>

<script is:inline>
document.addEventListener('DOMContentLoaded', () => {
    const container = document.querySelector('.carousel-container');
    const track = document.querySelector('.testimonial-track');
    const prevButton = document.getElementById('prevBtn');
    const nextButton = document.getElementById('nextBtn');
    
    if (!track || !container) return;

    let slides = Array.from(track.children);
    const originalSlideCount = slides.length;
    let isTransitioning = false;
    
    const clonesCount = 2;

    for (let i = 0; i < clonesCount; i++) {
        const index = originalSlideCount - 1 - i;
        const clone = slides[index].cloneNode(true);
        clone.classList.add('clone');
        track.insertBefore(clone, slides[0]);
    }
    for (let i = 0; i < clonesCount; i++) {
        const clone = slides[i].cloneNode(true);
        clone.classList.add('clone');
        track.appendChild(clone);
    }

    slides = Array.from(track.children);
    let currentIndex = clonesCount;

    // --- Autoplay variables ---
    let autoPlayInterval;
    const autoPlayDelay = 10000; // 10 seconds

    // --- NEW: Touch variables ---
    let touchStartX = 0;
    let touchEndX = 0;
    const swipeThreshold = 50; // Minimum horizontal pixel distance for a swipe to register

    const getSlideWidth = () => {
        const slide = slides[0];
        if (!slide) return 0;
        const slideStyle = window.getComputedStyle(slide);
        const slideMarginRight = parseInt(slideStyle.marginRight, 10);
        return slide.clientWidth + slideMarginRight;
    };

    const setPosition = (instant = false) => {
        if (instant) track.style.transition = 'none';
        
        const offset = -currentIndex * getSlideWidth();
        track.style.transform = `translateX(${offset}px)`;

        if (instant) {
            setTimeout(() => {
                track.style.transition = 'transform 0.5s ease-in-out';
            }, 50);
        }
    };
    
    const moveToNext = () => {
        if (isTransitioning) return;
        isTransitioning = true;
        currentIndex++;
        setPosition();
    };
    
    const moveToPrev = () => {
        if (isTransitioning) return;
        isTransitioning = true;
        currentIndex--;
        setPosition();
    };

    const startAutoPlay = () => {
        clearInterval(autoPlayInterval);
        autoPlayInterval = setInterval(() => {
            moveToNext();
        }, autoPlayDelay);
    };

    // --- UPDATED: Event listeners now reset the autoplay timer ---
    nextButton.addEventListener('click', () => {
        moveToNext();
        startAutoPlay();
    });

    prevButton.addEventListener('click', () => {
        moveToPrev();
        startAutoPlay();
    });

    // --- NEW: Touch Event Handlers ---
    container.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX;
    });

    container.addEventListener('touchend', (e) => {
        touchEndX = e.changedTouches[0].screenX;
        const deltaX = touchEndX - touchStartX;

        // Check if the swipe is significant enough
        if (Math.abs(deltaX) > swipeThreshold) {
            if (deltaX > 0) {
                // Swipe to the right for "previous" slide
                moveToPrev();
            } else {
                // Swipe to the left for "next" slide
                moveToNext();
            }
            startAutoPlay(); // Reset autoplay timer after a manual swipe
        }
    });

    track.addEventListener('transitionend', () => {
        if (currentIndex >= originalSlideCount + clonesCount) {
            currentIndex = clonesCount;
            setPosition(true);
        }
        if (currentIndex < clonesCount) {
            currentIndex = originalSlideCount + clonesCount - 1;
            setPosition(true);
        }
        isTransitioning = false;
    });

    container.addEventListener('mouseenter', () => {
        clearInterval(autoPlayInterval);
    });

    container.addEventListener('mouseleave', () => {
        startAutoPlay();
    });

    // --- Initial setup ---
    setPosition(true);
    startAutoPlay();
    window.addEventListener('resize', () => {
        setPosition(true);
        startAutoPlay();
    });
});
</script>